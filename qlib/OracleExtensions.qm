# -*- mode: qore; indent-tabs-mode: nil -*-
# @file OracleExtensions.qm OracleExtensions module definition

/*  OracleExtensions.qm Copyright (C) 2012 - 2014 Qore Technologies s.r.o.

Permission is hereby granted, free of charge, to any person obtaining a
copy of this software and associated documentation files (the "Software"),
to deal in the Software without restriction, including without limitation
the rights to use, copy, modify, merge, publish, distribute, sublicense,
and/or sell copies of the Software, and to permit persons to whom the
Software is furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
DEALINGS IN THE SOFTWARE.
*/

%new-style
%requires qore >= 0.8.7
%requires oracle

module OracleExtensions {
    version = "1.1";
    desc = "Extended functionality for Oracle Db driver";
    author = "Petr Vanek";
    url = "http://qore.org";
    license = "MIT";
}

/*  Version History
    * 2014-01-24 v1.1: Petr Vanek <petr.vanek@qoretechnologies.com>
      + OracleSQLstatement implemented
      + documentation fixes
    * 2012-02-05 v1.0: Petr Vanek <petr.vanek@qoretechnologies.com>
      + initial implementation
*/

/** @mainpage OracleExtensions Module

The %OracleExtensions module provides functionality for advanced Oracle DBMS
operations or tools.

To use this module, use \c "%requires OracleExtensions" in your code.

All the public symbols in the module are defined in the OracleExtensions namespace.

@note Standard Qore oracle module is required to be installed. 

OracleExtensions scope is:

- @ref instrumentation
- @ref dbms_output

@section instrumentation Code Instrumentation

- @ref OracleExtensions::OracleApplicationInfo
- @ref OracleExtensions::OracleLongOps

@subsection instrumentation_info Application Info

To provide functionality of DBMS_APPLICATION_INFO package (exec grant required)
for \c Datasource and \c DatasourcePool objects.

Application developers or DBAs can use this functionality together with Oracle
Trace and the SQL trace facility to record names of executing modules or
transactions in the database for later use when tracking the performance
of various modules and debugging.

Values provided to OracleExtensions::OracleApplicationInfo are used in \c V$SESSION or \c V$SQLAREA views
for DBA tasks.

Application info is composed of three components in following hierarchy of
logical depencency:

- \c Client, the client info of the session
- \c Module, the name of the module that is currently running
- \c Action, the name of the current action within the current \c Module

@note All application info components are optional and using eg. only one
  of them is valid approach.

<b>Relevant Classes:</b>

- @ref OracleExtensions::OracleApplicationInfo
- @ref OracleExtensions::OracleDatasource
- @ref OracleExtensions::OracleDatasourcePool
- @ref OracleExtensions::OracleSQLStatement

OracleDatasource and OracleDatasourcePool includes 
Qore::Datasource and Qore::DatasourcePool inside and all overriden methods keep
their original properties: transaction handling, return data, optional arguments...

@subsubsection instrumentation_info_scope Application Info Scope

- Persistent: it stays until trnsaction exists.
    - beginTransaction, setAppInfo
- One-time: used with select fanily mathods outside of the transaction.
- Automatic: see @ref instrumentation_info_auto

@subsubsection instrumentation_info_auto Automatic Application Info

There is an optional argument in all @ref OracleExtensions::OracleDatasource
and @ref OracleExtensions::OracleDatasourcePool constructors: \c userAutoInfo,
type \c code.

This user code allows to specify function (or closure) to define automatic
Application Info for method calls where there is no explicit info used.

@note User code used for Automatic Application Info obtaining should return
      NOTHING or OracleExtensions::OracleApplicationInfo instance. A type
      cast exception is raised otherwise.

  
@subsubsection instrumentation_info_examples Examples

@code
%new-style

OracleExtensions::OracleDatasource ds("oracle", "user", "pass", "db");
OracleExtensions::OracleApplicationInfo audit("my client", "my module", "a action");
hash res1 = ds.select(a, "select * from a_very_huge_table where fullscan_column = %v", 1);
...
hash res2 = ds.select("select * from a_very_huge_table where fullscan_column = %v", 1);
@endcode

The code above has some important characteristics:

- \c V$SESSION will hold audit's values in appropriate columns while the statement runs
- Transaction handling remains the same as in Qore::Datasource case
- Data returned from \c select method are the same as in Qore::Datasource
- The default application info will be used (if found) in 2nd case - without specified OracleExtensions::OracleApplicationInfo instance.

Next example explains how to use @ref instrumentation_info_auto

@code
# user code to get default/automatic Application Info.
*OracleExtensions::OracleApplicationInfo sub getAutoInfo()
{
    printf("getAutoInfo: called\n");
    return new OracleExtensions::OracleApplicationInfo("user module", "auto info", "auto info");
}

# a constructor with standard arguments - ellipsed with "..." in this example
# The function \c getAutoInfo is registered in OracleDatasource as @ref call-reference
OracleExtensions::OracleDatasource dd(..., \getAutoInfo());
dd.select("select * from huge_table where fullscan = 1");
@endcode


@subsection instrumentation_longops Long Operations

This functionality can be used to show the progress of long operations by
inserting rows in the \c V$SESSION_LONGOPS view. For it to work effectively,
you must know the total amount of work you are planning to do and how much
work you have done so far.

<b>Relevant Classes:</b>

- @ref OracleExtensions::OracleLongOps
- @ref OracleExtensions::OracleDatasource
- @ref OracleExtensions::OracleDatasourcePool

@subsubsection instrumentation_longops_example Examples

@code
%new-style

OracleDatasource ds("oracle", "user", "pass", "db");

int max = 10;
OracleExtensions::OracleLongOps lo('running potatoes counting', 'FOOBAR table', 'potatoes', max);
for (int i = 1; i <= max; i++) {
    lo.sofar = i;
    lo.op_context = i * 1000;
    db.setLongOpsProgress(lo);
    sleep(1);
}
@endcode

it will result in this line in V$SESSION_LONGOPS:

|!...|!OPNAME|!TARGET|!TARGET_DESC|!SOFAR|!TOTALWORK|!UNITS|!...|!MESSAGE|!...
|...|running potatoes counting|{null}|FOOBAR table|10|10|potatoes|...|running potatoes counting: FOOBAR table : 10 out of 10 potatoes done|...


@section dbms_output DBMS_OUTPUT Wrapper

The \c DBMS_OUTPUT package wrappers (exec grant required) enable you
to send messages from stored procedures, packages, and triggers. The package
is especially useful for displaying PL/SQL debugging information.

<b>Relevant Classes:</b>

- @ref OracleExtensions::OracleDatasource
- @ref OracleExtensions::OracleDatasourcePool

@subsection dbms_output_examples Examples

@code
%new-style

OracleExtensions::OracleDatasource ds("oracle", "user", "pass", "db");

ds.outputEnable();
# qore client side
ds.outputPutLine('foo');
ds.outputPutLine(111);
ds.outputPutLine(now());
# call any PL/SQL unit on server with DBMS_OUTPUT.PUT... inits body
ds.exec("begin dbms_output.put_line(%v); end;", "hey, it's server here");

my *string res = o.outputGet();
printf("   RESULT: %N\n", res);
ds.outputDisable();
@endcode

will print out:

@code
   RESULT: "foo
111
20130301151736
hey, it's server here
"
@endcode

*/


#! public OracleExtensions namespace defines stuff for use
public namespace OracleExtensions {

#! A base class for @ref instrumentation_info_auto related classes. Not intended to be used directly.
public class OracleInstrumentationBase
{
    private {
        #! potential user Application Info set by beginTransaction or explicit call of setAppInfo
        *OracleExtensions::OracleApplicationInfo userInfo;
        #! user code used in setAutomaticDBInfo when there is no OracleApplicationInfo value provided
        *code autoCode;
        #! Internally used datasource/pool
        object m_ds;
    }
    
    constructor(*code userAutoInfo) {
        autoCode = userAutoInfo;
        userInfo = NOTHING;
    }
    
    object privateDS() { return m_ds; }
    *code autoCode() { return autoCode; }
    
    #! Obtain info about transaction capturing and try to get available Application Info
    /** 
        @param item optional OracleApplicationInfo with value or NOTHING
        @param checkTransaction default=True. True = check if there is a transaction. False = do not check.
        @retval bool True if the \c ds will be rollbacked explicitly

        The transaction handling is for example:

            - select: check if there is a transaction: no? rollback after run.
            - exec: yes! do not rollback - the transaction will be handled upsetream in user code

     */
    bool setAutomaticDBInfo(*OracleExtensions::OracleApplicationInfo item, bool checkTransaction=True) {

        # do not set auto info when there is already user defined one
        if (!exists item && exists userInfo) {
            return False;
        }

        # ensure there is no transaction at the beginning to be safe
        # to ROLLBACK auditing changes
        bool doRollback = False;
        if (checkTransaction && !m_ds.currentThreadInTransaction()) {
            doRollback = True;
        }

        *OracleExtensions::OracleApplicationInfo audit;

        if (exists item) {
            audit = item;
        }
        else if (exists autoCode) {
            audit = autoCode();
        }

        if (audit) {
            setAppInfo(audit);
        }

        return doRollback;
    }

    #! Set the explicit @ref instrumentation_info. The transaction lock is taken.
    /**
    @param audit a OracleExtensions::OracleApplicationInfo instance with info
    @param fromSystem a flag if it goes from "system call". End user code usually does not need to use it.
    */
    setAppInfo(*OracleExtensions::OracleApplicationInfo audit, bool fromSystem=True) {
        if (exists userInfo && (!exists audit || audit.isEmpty())) {
            userInfo = NOTHING;
        }
        else if (!fromSystem) {
            userInfo = audit;
        }
        else if (exists userInfo &&  exists audit 
                 && userInfo.client == audit.client
                 && userInfo.module == audit.module
                 && userInfo.action == audit.action) {
            return;
        }

        try {
            m_ds.exec("begin
                    dbms_application_info.set_client_info(%v);
                    dbms_application_info.set_module(%v, %v);
                end;", audit.client, audit.module, audit.action);
        }
        catch (ex) {
            # We don't want to throw a real error here because it's just a helper
            # functionality - business logic should continue when there is no DBMS_APPLICATION_INFO
            # available...
            stderr.printf("OracleExtensions WARNING: setAppInfo: %s - %s\n", ex.err, ex.desc);
        }
    }
    
    #! An overloaded method with the same functionality as the OracleExtensions::OracleApplicationInfo variant
    setAppInfo(*string client, *string module, *string action, bool fromSystem=True) {
        OracleExtensions::OracleApplicationInfo item(client, module, action);
        if (!item.isEmpty())
            setAppInfo(item, fromSystem);
    }


} # class OracleInstrumentationBase

#! A base class for OracleDatasource and OracleDatasourcePool. Not intended to be used directly.
public class OracleDatasourceBase inherits Qore::SQL::AbstractDatasource, OracleInstrumentationBase
{    
    #! AbstractDatasource implementation for Datasource and DatasourcePool
    *string getDBName() { return m_ds.getDBName(); }
    #! AbstractDatasource implementation for Datasource and DatasourcePool
    *string getUserName() { return m_ds.getUserName(); }
    #! AbstractDatasource implementation for Datasource and DatasourcePool
    any getServerVersion() { return m_ds.getServerVersion(); }
    #! AbstractDatasource implementation for Datasource and DatasourcePool
    *string getPassword() { return m_ds.getPassword(); }
    #! AbstractDatasource implementation for Datasource and DatasourcePool
    hash getConfigHash() { return m_ds.getConfigHash(); }
    #! AbstractDatasource implementation for Datasource and DatasourcePool
    *int getPort() { return m_ds.getPort(); }
    #! AbstractDatasource implementation for Datasource and DatasourcePool
    string getConfigString() { return m_ds.getConfigString(); }
    #! AbstractDatasource implementation for Datasource and DatasourcePool
    any getClientVersion() { return m_ds.getClientVersion(); }
    #! AbstractDatasource implementation for Datasource and DatasourcePool
    *string getOSEncoding() { return m_ds.getOSEncoding(); }
    #! AbstractDatasource implementation for Datasource and DatasourcePool
    string getDriverName() { return m_ds.getDriverName(); }
    #! AbstractDatasource implementation for Datasource and DatasourcePool
    string getDBEncoding() { return m_ds.getDBEncoding(); }
    #! AbstractDatasource implementation for Datasource and DatasourcePool
    *string getHostName() { return m_ds.getHostName(); }
    #! AbstractDatasource implementation for Datasource and DatasourcePool
    bool inTransaction() { return m_ds.inTransaction(); }

    #! Start new transaction with Aplication info set as strings
    /**
    @param client optional string, application info \c Client
    @param module optional string, application info \c Module
    @param action optional string, application info \c Action

    Currently used application info will be used in any following
    method calls if there is no OracleExtensions::OracleApplicationInfo instance used.
    */
    nothing beginTransaction(*string client, *string module, *string action) {
        m_ds.beginTransaction();
        setAppInfo(client, module, action, False);
    }
    #! Start new transaction with Aplication info set as object
    /**
    @param info mandatory. Application info object instance

    Currently used application info will be used in any following
    method calls if there is no OracleExtensions::OracleApplicationInfo instance used.
    */
    nothing beginTransaction(OracleExtensions::OracleApplicationInfo info) {
        m_ds.beginTransaction();
        setAppInfo(info, False);
    }
    #! Start new transaction with potential automatic Aplication info set
    /**
        There is no user info provided. OracleDatasource tries to find
        the appropriate Application info automatically if possible.
     */
    nothing beginTransaction() {
        m_ds.beginTransaction();
        setAutomaticDBInfo(NOTHING, False);
    }

    #! exec with automatic approach of getting application info
    /**
        @param sql a SQL statement 
        @param ... binding arguments as in parent class method
        @retval any a result as in parent class method

    This method tries to find application info automatically. The previously set
    info (beginTransaction, setAppInfo) is used or a context related info
    is used in Qorus Integration Engine.
     */
    any exec(string sql) {
        bool doRollback = setAutomaticDBInfo(); 
        on_error {
            if (doRollback)
                rollback();
        }
        #setAutomaticDBInfo(NOTHING, False); 
        return m_ds.vexec(sql, argv);
    }

    #! execRaw with automatic approach of getting application info
    /**
        @param sql a SQL statement 
        @retval any a result as in parent class method

    This method tries to find application infautomatically. The previously set
    info (beginTransaction, setAppInfo) is used or a context related info
    is used in Qorus Integration Engine.
     */
    any execRaw(string sql) {
        bool doRollback = setAutomaticDBInfo(); 
        on_error {
            if (doRollback)
                rollback();
        }
        #setAutomaticDBInfo(NOTHING, False); 
        return m_ds.execRaw(sql);
    }

    #! select with automatic approach of getting application info
    /**
        @param sql a SQL statement 
        @param ... binding arguments as in parent class method
        @retval any a result as in parent class method

    This method tries to find application info automatically. The previously set
    info (beginTransaction, setAppInfo) is used or a context related info
    is used in Qorus Integration Engine.
     */
    any select(string sql) {
        bool doRollback = setAutomaticDBInfo(); 
        on_exit {
            if (doRollback)
                rollback();
        }
        return m_ds.vselect(sql, argv);
    }

    #! selectRow with automatic approach of getting application info
    /**
        @param sql a SQL statement 
        @param ... binding arguments as in parent class method
        @retval any a result as in parent class method

    This method tries to find application info automatically. The previously set
    info (beginTransaction, setAppInfo) is used or a context related info
    is used in Qorus Integration Engine.
     */
    any selectRow(string sql) {
        bool doRollback = setAutomaticDBInfo(); 
        on_exit {
            if (doRollback)
                rollback();
        }
        return m_ds.vselectRow(sql, argv);
    }

    #! selectRows with automatic approach of getting application info
    /**
        @param sql a SQL statement 
        @param ... binding arguments as in parent class method
        @retval any a result as in parent class method

    This method tries to find application info automatically. The previously set
    info (beginTransaction, setAppInfo) is used or a context related info
    is used in Qorus Integration Engine.
     */
    any selectRows(string sql) {
        bool doRollback = setAutomaticDBInfo(); 
        on_exit {
            if (doRollback)
                rollback();
        }
        return m_ds.vselectRows(sql, argv);
    }

    #! vexec with automatic approach of getting application info
    /**
        @param sql a SQL statement 
        @param ... binding arguments as in parent class method
        @retval any a result as in parent class method

    This method tries to find application info automatically. The previously set
    info (beginTransaction, setAppInfo) is used or a context related info
    is used in Qorus Integration Engine.
     */
    any vexec(string sql, softlist vargs) {
        bool doRollback = setAutomaticDBInfo(); 
        on_error {
            if (doRollback)
                rollback();
        }
        #setAutomaticDBInfo(NOTHING, False); 
        return m_ds.vexec(sql, vargs);
    }

    #! vselect with automatic approach of getting application info
    /**
        @param sql a SQL statement 
        @param ... binding arguments as in parent class method
        @retval any a result as in parent class method

    This method tries to find application info automatically. The previously set
    info (beginTransaction, setAppInfo) is used or a context related info
    is used in Qorus Integration Engine.
     */
    any vselect(string sql, softlist vargs) {
        bool doRollback = setAutomaticDBInfo(); 
        on_exit {
            if (doRollback)
                rollback();
        }
        return m_ds.vselect(sql, vargs);
    }

    #! vselectRow with automatic approach of getting application info
    /**
        @param sql a SQL statement 
        @param ... binding arguments as in parent class method
        @retval any a result as in parent class method

    This method tries to find application info automatically. The previously set
    info (beginTransaction, setAppInfo) is used or a context related info
    is used in Qorus Integration Engine.
     */
    any vselectRow(string sql, softlist vargs) {
        bool doRollback = setAutomaticDBInfo(); 
        on_exit {
            if (doRollback)
                rollback();
        }
        return m_ds.vselectRow(sql, vargs);
    }

    #! vselectRows with automatic approach of getting application info
    /**
        @param sql a SQL statement 
        @param ... binding arguments as in parent class method
        @retval any a result as in parent class method

    This method tries to find application info automatically. The previously set
    info (beginTransaction, setAppInfo) is used or a context related info
    is used in Qorus Integration Engine.
     */
    any vselectRows(string sql, softlist vargs) {
        bool doRollback = setAutomaticDBInfo(); 
        on_exit {
            if (doRollback)
                rollback();
        }
        return m_ds.vselectRows(sql, vargs);
    }

    #! exec with user defined application info
    /**
        @param info a OracleExtensions::OracleApplicationInfo instance
        @param sql a SQL statement 
        @param ... binding arguments as in parent class method
        @retval any a result as in parent class method

    This method sets given application info. The previously set
    info (beginTransaction, setAppInfo) is overriden and the context related info
    is skipped.
     */
    any exec(OracleExtensions::OracleApplicationInfo info, string sql) {
        bool doRollback = setAutomaticDBInfo(info); 
        on_error {
            if (doRollback)
                rollback();
        }
        #setAutomaticDBInfo(info, False); 
        return m_ds.vexec(sql, argv);
    }

    #! execRaw with user defined application info
    /**
        @param info a OracleExtensions::OracleApplicationInfo instance
        @param sql a SQL statement 
        @retval any a result as in parent class method

    This method sets given application info. The previously set
    info (beginTransaction, setAppInfo) is overriden and the context related info
    is skipped.
     */
    any execRaw(OracleExtensions::OracleApplicationInfo info, string sql) {
        bool doRollback = setAutomaticDBInfo(info); 
        on_error {
            if (doRollback)
                rollback();
        }
        #setAutomaticDBInfo(info, False); 
        return m_ds.execRaw(sql);
    }

    #! select with user defined application info
    /**
        @param info a OracleExtensions::OracleApplicationInfo instance
        @param sql a SQL statement 
        @param ... binding arguments as in parent class method
        @retval any a result as in parent class method

    This method sets given application info. The previously set
    info (beginTransaction, setAppInfo) is overriden and the context related info
    is skipped.
     */
    any select(OracleExtensions::OracleApplicationInfo info, string sql) {
        bool doRollback = setAutomaticDBInfo(info); 
        on_exit {
            if (doRollback)
                rollback();
        }
        return m_ds.vselect(sql, argv);
    }

    #! selectRow with user defined application info
    /**
        @param info a OracleExtensions::OracleApplicationInfo instance
        @param sql a SQL statement 
        @param ... binding arguments as in parent class method
        @retval any a result as in parent class method

    This method sets given application info. The previously set
    info (beginTransaction, setAppInfo) is overriden and the context related info
    is skipped.
     */
    any selectRow(OracleExtensions::OracleApplicationInfo info, string sql) {
        bool doRollback = setAutomaticDBInfo(info); 
        on_exit {
            if (doRollback)
                rollback();
        }
        return m_ds.vselectRow(sql, argv);
    }

    #! selectRows with user defined application info
    /**
        @param info a OracleExtensions::OracleApplicationInfo instance
        @param sql a SQL statement 
        @param ... binding arguments as in parent class method
        @retval any a result as in parent class method

    This method sets given application info. The previously set
    info (beginTransaction, setAppInfo) is overriden and the context related info
    is skipped.
     */
    any selectRows(OracleExtensions::OracleApplicationInfo info, string sql) {
        bool doRollback = setAutomaticDBInfo(info); 
        on_exit {
            if (doRollback)
                rollback();
        }
        return m_ds.vselectRows(sql, argv);
    }

    #! vexec with user defined application info
    /**
        @param info a OracleExtensions::OracleApplicationInfo instance
        @param sql a SQL statement 
        @param ... binding arguments as in parent class method
        @retval any a result as in parent class method

    This method sets given application info. The previously set
    info (beginTransaction, setAppInfo) is overriden and the context related info
    is skipped.
     */
    any vexec(OracleExtensions::OracleApplicationInfo info, string sql) {
        bool doRollback = setAutomaticDBInfo(info); 
        on_error {
            if (doRollback)
                rollback();
        }
        #setAutomaticDBInfo(info, False); 
        return m_ds.vexec(sql, elements argv ? argv[0] : NOTHING);
    }

    #! vselect with user defined application info
    /**
        @param info a OracleExtensions::OracleApplicationInfo instance
        @param sql a SQL statement 
        @param ... binding arguments as in parent class method
        @retval any a result as in parent class method

    This method sets given application info. The previously set
    info (beginTransaction, setAppInfo) is overriden and the context related info
    is skipped.
     */
    any vselect(OracleExtensions::OracleApplicationInfo info, string sql) {
        bool doRollback = setAutomaticDBInfo(info); 
        on_exit {
            if (doRollback)
                rollback();
        }
        return m_ds.vselect(sql, elements argv ? argv[0] : NOTHING);
    }

    #! vselectRow with user defined application info
    /**
        @param info a OracleExtensions::OracleApplicationInfo instance
        @param sql a SQL statement 
        @param ... binding arguments as in parent class method
        @retval any a result as in parent class method

    This method sets given application info. The previously set
    info (beginTransaction, setAppInfo) is overriden and the context related info
    is skipped.
     */
    any vselectRow(OracleExtensions::OracleApplicationInfo info, string sql) {
        bool doRollback = setAutomaticDBInfo(info); 
        on_exit {
            if (doRollback)
                rollback();
        }
        return m_ds.vselectRow(sql, elements argv ? argv[0] : NOTHING);
    }

    #! vselectRows with user defined application info
    /**
        @param info a OracleExtensions::OracleApplicationInfo instance
        @param sql a SQL statement 
        @param ... binding arguments as in parent class method
        @retval any a result as in parent class method

    This method sets given application info. The previously set
    info (beginTransaction, setAppInfo) is overriden and the context related info
    is skipped.
     */
    any vselectRows(OracleExtensions::OracleApplicationInfo info, string sql) {
        bool doRollback = setAutomaticDBInfo(info); 
        on_exit {
            if (doRollback)
                rollback();
        }
        return m_ds.vselectRows(sql, elements argv ? argv[0] : NOTHING);
    }

}

#! Fill the attributes. @param userAutoInfo see @ref instrumentation_info_auto
OracleDatasourceBase::constructor(*code userAutoInfo)
    : OracleInstrumentationBase(userAutoInfo)
{
    userInfo = NOTHING;
}

#! Commit the transaction. Application info is cleared. DBMS_OUTPUT disabled.
nothing OracleDatasourceBase::commit() {
    # required to clear info
    setAppInfo(NOTHING, False);
    outputDisable();
    m_ds.commit();
}

#! Rollback the transaction. Application info is cleared. DBMS_OUTPUT disabled.
nothing OracleDatasourceBase::rollback() {
    # required to clear info
    setAppInfo(NOTHING, False);
    outputDisable();
    m_ds.rollback();
}

#! Set current OracleLongOps
OracleDatasourceBase::setLongOpsProgress(OracleLongOps lo) {
    hash res = m_ds.exec("declare
        v_rindex     PLS_INTEGER := %v;
        v_slno       PLS_INTEGER := %v;
        v_obj        PLS_INTEGER;
    BEGIN
        --
        if v_rindex is NULL then
            v_rindex := DBMS_APPLICATION_INFO.set_session_longops_nohint;
        end if;
        --
        DBMS_APPLICATION_INFO.set_session_longops(rindex  => v_rindex, 
                                          slno        => v_slno,
                                          op_name     => %v, 
                                          target      => v_obj, 
                                          context     => %v, 
                                          sofar       => %v, 
                                          totalwork   => %v, 
                                          target_desc => %v, 
                                          units       => %v);
        --
        :out_rindex := v_rindex;
        :out_slno := v_slno;
        --
    end;", lo.getRindex(), lo.getSlno(),
           lo.op_name, lo.op_context, lo.sofar, lo.totalwork, lo.target_desc, lo.units,
           Type::Int, Type::Int
    );

    if (!exists lo.getRindex())
        lo.setRindex(res.out_rindex);
    if (!exists lo.getSlno())
        lo.setSlno(res.out_slno);
}

#! Explicitly enable DBMS_OUTPUT buffer
OracleDatasourceBase::outputEnable(*int bufferSize) {
    if (exists bufferSize && (bufferSize < 2000 || bufferSize > 1000000)) {
        throw "ORACLE-SERVEROUTPUT-ERROR", sprintf("Buffer size has to be between 2000 and 1000000. Got: %d", bufferSize);
    }
    m_ds.exec("begin dbms_output.enable(%v); end;", bufferSize);
}

#! Explicitly close DBMS_OUTPUT buffer
OracleDatasourceBase::outputDisable() {
    if (m_ds.currentThreadInTransaction()) {
        m_ds.exec("begin dbms_output.disable(); end;");
    }
}

#! Append string to DBMS_OUTPUT buffer without end of line
OracleDatasourceBase::outputPut(softstring text) {
    outputEnable();
    m_ds.exec("begin dbms_output.put(%v); end;", text);
}

#! Append string to DBMS_OUTPUT buffer with end of line
OracleDatasourceBase::outputPutLine(softstring text) {
    outputEnable();
    m_ds.exec("begin dbms_output.put_line(%v); end;", text);
}

#! Get the DBMS_OUTPUT buffer
*string OracleDatasourceBase::outputGet() {
    int valid = 0;
    string result;
    
    while (valid == 0) {
        hash res = m_ds.exec("begin dbms_output.get_line(:line, :valid); end;", Type::String, Type::Int);
        valid = res.valid;
        if (valid == 0)
            result += res.line + "\n";
    }
    
    return result;
}

#! OracleExtensions::OracleApplicationInfo holds user info for @ref instrumentation_info
/** Objects of this class do not execute any functionality.
Only string values are hold here.

See @ref instrumentation_info_examples
 */
public class OracleApplicationInfo
{
    public {
        #! Supplies any additional information about the client application. This information is stored in the V$SESSION view. Information exceeding 64 bytes is truncated.
        *string client;
        #! Name of module that is currently running. When the current module terminates, call this procedure with the name of the new module if there is one, or NULL if there is not. Names longer than 48 bytes are truncated.
        *string module;
        #! Name of current action within the current module. If you do not want to specify an action, this value should be NULL. Names longer than 32 bytes are truncated.
        *string action;
    }

    #! Create OracleExtensions::OracleApplicationInfo instance
    /**
        See @ref instrumentation_info description or Oracle documentation.

        @param client an optional string with \c Client value
        @param module an optional string with \c Module value
        @param action an optional string with \c Action value
    */
    constructor(*string client, *string module, *string action) {
        self.client = client;
        self.module = module;
        self.action = action;
    }

    #! Clear values from all attributes
    clear() {
        client = NOTHING;
        module = NOTHING;
        action = NOTHING;
    }

    #! Check if is the instance empty or with at least one value
    /**
        @retval bool \c True when is at least one of attributes set with value
     */
    bool isEmpty() {
        return !exists client && !exists module && !exists action;
    }

} # class OracleApplicationInfo

#! Qore wrapper/helper for @ref instrumentation_longops
/** Instanes of this class do not make any changes in the database server.
All changes are performed by @ref OracleDatasource or @ref OracleDatasourcePool.
OracleExtensions::OracleLongOps just hold required attributes. It performs client side checks
of attributes validity too.

See @ref instrumentation_longops_example
*/
public class OracleLongOps
{
    public {
        #! The name of the long running task. It appears as the OPNAME column of v$session_longops.
        string op_name;
        #! The description of the object being manipulated in this long operation. This provides a caption for the target parameter. This value appears in the TARGET_DESC field of v$session_longops.
        string target_desc;
        #! Specifies the units in which sofar and totalwork are being represented. It appears as the UNITS field of v$session_longops.
        string units;
        #! Any number the client wants to store. It appears in the CONTEXT column of v$session_longops.
        int op_context = 0;
        #! Any number the client wants to store. It appears in the SOFAR column of v$session_longops. This is typically the amount of work which has been done so far.
        int sofar;
        #! Any number the client wants to store. It appears in the TOTALWORK column of v$session_longops. This is typically an estimate of the total amount of work needed to be done in this long running operation.
        int totalwork;
    }
    private {
        # A token which represents the v$session_longops row to update. Set this to set_session_longops_nohint to start a new row. Use the returned value from the prior call to reuse a row.
        *int rindex;
        # Saves information across calls to set_session_longops: It is for internal use and should not be modified by the caller.
        *int slno;
        # Specifies the object that is being worked on during the long running operation. For example, it could be a table ID that is being sorted. It appears as the TARGET column of v$session_longops.
        *int target;
    }

#! Create an OracleLongOps instance
/**
    @param op_name mandatory string. Specifies the name of the long running task
    @param target_desc mandatory string. Specifies the description of the object being manipulated in this long operation
    @param units mandatory string. Specifies the units in which sofar and totalwork are being represented
    @param totalwork mandatory int. Any number (greater than 0) the client wants to store

    It can trhow \c ORACLE-LONGOPS-ERROR when is some input parameter ot of allowed size.
 */
/*OracleLongOps::*/constructor(string op_name, string target_desc, string units, int totalwork) {
    if (op_name.strlen() > 64)
        throw "ORACLE-LONGOPS-ERROR",
              sprintf("Constructor argument 'op_name' must have length 64 bytes max. Got: %d", op_name.strlen());
    self.op_name = op_name;

    if (target_desc.strlen() > 32)
        throw "ORACLE-LONGOPS-ERROR",
              sprintf("Constructor argument 'target_desc' must have length 32 bytes max. Got: %d", target_desc.strlen());
    self.target_desc = target_desc;

    if (target_desc.strlen() > 32)
        throw "ORACLE-LONGOPS-ERROR",
              sprintf("Constructor argument 'units' must have length 32 bytes max. Got: %d", target_desc.strlen());
    self.units = units;
    
    if (totalwork < 1)
        throw "ORACLE-LONGOPS-ERROR",
              sprintf("Constructor argument 'totalwork' must have greater than 0. Got: %d", totalwork);
    self.totalwork = totalwork;

    sofar = 0;
}

#! Get info if is the long operation finished or not from the totalwork/sofar comparsion
/**
    @retval bool True is totalwork did not met the sofar attribute
 */
bool /*OracleLongOps::*/inProgress() {
    return totalwork != sofar;
}

#! Get the value of target attribute
/** @retval *int a target value
Target specifies the object that is being worked on during the long
running operation. For example, it could be a table ID that is being
sorted. It appears as the TARGET column of \c v$session_longops.
 */
*int /*OracleLongOps::*/getTarget() {
    return target;
}

} # class OracleLongOps

#! Do not use if you don't know what it is.
/** @retval *int rindex value

Rindex is a token which represents the \c v$session_longops row to
update. Set this to set_session_longops_nohint to start a new row.
Use the returned value from the prior call to reuse a row.
 */
*int OracleLongOps::getRindex() {
    return rindex;
}
#! Do not use if you don't know what it is.
/** @param i int a new value for rindex

Rindex is a token which represents the \c v$session_longops row to
update. Set this to set_session_longops_nohint to start a new row.
Use the returned value from the prior call to reuse a row.
*/
OracleLongOps::setRindex(int i) {
    if (!exists rindex)
        rindex = i;
    else
        throw "ORACLE-LONGOPS-ERROR", sprintf("Cannot set new value to rindex when there is already one set: %d", rindex);
}

#! Do not use if you don't know what it is.
/** @retval *int rindex value
    
    Slno saves information across calls to set_session_longops: It is
    for internal use and should not be modified by the caller.
 */
*int OracleLongOps::getSlno() {
    return slno;
}
#! Do not use if you don't know what it is.
/** @param i int a new value for slno

    Slno saves information across calls to set_session_longops: It is
    for internal use and should not be modified by the caller.
 */
OracleLongOps::setSlno(int i) {
    if (!exists slno)
        slno = i;
    else
        throw "ORACLE-LONGOPS-ERROR", sprintf("Cannot set new value to slno when there is already one set: %d", slno);
}


#! OracleDatasourcePool class implementation
/**
It wraps Qore::DatasourcePool.
 */
public class OracleDatasourcePool inherits OracleExtensions::OracleDatasourceBase {

    #! Standard Qore::DatasourcePool constructor
    /**
        @param userAutoInfo see @ref instrumentation_info_auto
     */
    constructor(string driver, *string user, *string pass, *string db, *string encoding, *string host, softint min=3, softint max=10, softint port=0, *code userAutoInfo)
        : OracleExtensions::OracleDatasourceBase(userAutoInfo)
    {
        m_ds = new DatasourcePool(driver, user, pass, db, encoding, host, min, max);
    }
    #! Standard Qore::DatasourcePool constructor
    /**
        @param userAutoInfo see @ref instrumentation_info_auto
     */
    constructor(string desc, *code userAutoInfo)
        : OracleExtensions::OracleDatasourceBase(userAutoInfo)
    {
        m_ds = new DatasourcePool(desc);
    }
    #! Standard Qore::DatasourcePool constructor
    /**
        @param userAutoInfo see @ref instrumentation_info_auto
     */
    constructor(hash opts, *code userAutoInfo)
        : OracleExtensions::OracleDatasourceBase(userAutoInfo)
    {
        m_ds = new DatasourcePool(opts);
    }
    #! New constructor: use already existing DatasourcePool.
    /** The original DatasourcePool is embedded into this object.

        @param userAutoInfo see @ref instrumentation_info_auto
     */
    constructor(DatasourcePool ds, *code userAutoInfo)
        : OracleExtensions::OracleDatasourceBase(userAutoInfo)
    {
        m_ds = ds;
    }

} # class OracleDatasourcePool


#! OracleDatasource class implementation
/**
It wraps from Qore::Datasource.
 */
public class OracleDatasource inherits OracleExtensions::OracleDatasourceBase {

    #! Standard Qore::DatasourcePool constructor
    /**
        @param userAutoInfo see @ref instrumentation_info_auto
     */
    constructor(string driver, *string user, *string pass, *string db, *string encoding, *string host, softint port=0, *code userAutoInfo)
        : OracleExtensions::OracleDatasourceBase(userAutoInfo)
    {
        m_ds = new Datasource(driver, user, pass, db, encoding, host, port);
    }
    #! Standard Qore::DatasourcePool constructor
    /**
        @param userAutoInfo see @ref instrumentation_info_auto
     */
    constructor(string desc, *code userAutoInfo)
        : OracleExtensions::OracleDatasourceBase(userAutoInfo)
    {
        m_ds = new Datasource(desc);
    }
    #! Standard Qore::DatasourcePool constructor
    /**
        @param userAutoInfo see @ref instrumentation_info_auto
     */
    constructor(hash opts, *code userAutoInfo)
        : OracleExtensions::OracleDatasourceBase(userAutoInfo)
    {
        m_ds = new Datasource(opts);
    }
    #! New constructor: use  already existing Datasource
    /** The original Datasource is embedded into this instance.
    
        @param userAutoInfo see @ref instrumentation_info_auto
     */
    constructor(Datasource ds, *code userAutoInfo)
        : OracleExtensions::OracleDatasourceBase(userAutoInfo)
    {
        m_ds = ds;
    }
    
    nothing setAutoCommit(bool auto) {
        m_ds.setAutoCommit(auto);
    }

} # class OracleDatasource


#! Oracle specific SQLStatement variant with @ref instrumentation_info capabilities
/**
    @note Consult Qore::SQL::SQLStatement for its special transaction handling

    OracleSQLStatement can take standard Qore Datasource/Pool or OracleDatasource/Pool
    on input. The @ref instrumentation_info_auto handling is processed as follow:

    - Qore::SQL::Datasource or Qore::SQL::DatasourcePool
        - auto info code should be provided to OracleSQLStatement in its constructor
    - OracleDatasource of OracleDatasourcePool
        - the datasource-level auto info code is used

    <b>Example where the Auto Info goes from Oracle specialized datasource</b>

    \c getAutoInfo() is shared in all examples in the OracleExtension documentation.
    All constructor standard arguments are ellipsed with "..." in these examples.

    Both examples below result in the same behavior in the Oracle server.

    @code
OracleExtensions::OracleDatasource dd(..., \getAutoInfo());

OracleSQLStatement stmt(dd);
stmt.prepare("select * from foo");
while (stmt.next())
    process_row(stmt.fetchRow());

# remember the SQLStatement transaction handling
stmt.commit();
    @endcode
    
    <b>Example where the Auto Info goes from user code</b>
    @code
Datasource dd(...);

OracleSQLStatement stmt(dd, \getAutoInfo());
stmt.prepare("select * from foo");
while (stmt.next())
    process_row(stmt.fetchRow());

# remember the SQLStatement transaction handling
stmt.commit();
    @endcode
 */
public class OracleSQLStatement inherits Qore::SQL::SQLStatement, OracleExtensions::OracleInstrumentationBase {
    
    #! Constructor taking standard Datasource
    /**
    @param ds the Qore::SQL::Datasource instance
    @param userAutoInfo an optional code used for @ref instrumentation_info_auto
    */
    constructor(Qore::SQL::Datasource ds, *code userAutoInfo)
        : Qore::SQL::SQLStatement(ds),
          OracleExtensions::OracleInstrumentationBase(userAutoInfo)
    {
        m_ds = ds;
    }

    #! Constructor taking standard DatasourcePool
    /**
    @param ds the Qore::SQL::DatasourcePool instance
    @param userAutoInfo an optional code used for @ref instrumentation_info_auto
    */
    constructor(Qore::SQL::DatasourcePool ds, *code userAutoInfo)
        : Qore::SQL::SQLStatement(ds),
          OracleExtensions::OracleInstrumentationBase(userAutoInfo)
    {
        m_ds = ds;
    }

    #! Constructor taking OracleDatasource
    /**
    @param ds the OracleExtensions::OracleDatasource instance

    This constructor variant uses \c ds settings for @ref instrumentation_info_auto
    */
    constructor(OracleExtensions::OracleDatasource ds)
        : Qore::SQL::SQLStatement(ds.privateDS()),
          OracleExtensions::OracleInstrumentationBase(ds.autoCode())
    {
        m_ds = ds.privateDS();
    }

    #! Constructor taking OracleDatasourcePool
    /**
    @param ds the OracleExtensions::OracleDatasourcePool instance

    This constructor variant uses \c ds settings for @ref instrumentation_info_auto
    */
    constructor(OracleExtensions::OracleDatasourcePool ds)
        : Qore::SQL::SQLStatement(ds.privateDS()),
          OracleExtensions::OracleInstrumentationBase(ds.autoCode())
    {
        m_ds = ds.privateDS();
    }
    
    #! SQLStatement::exec with @ref instrumentation_info_auto
    nothing exec() {
        setAutomaticDBInfo();
        SQLStatement::execArgs(argv);
    }
    
    #! SQLStatement::execArgs with @ref instrumentation_info_auto
    nothing execArgs(softlist vargs) {
        setAutomaticDBInfo();
        SQLStatement::execArgs(vargs);
    }
    
    #! SQLStatement::next with @ref instrumentation_info_auto
    bool next() {
        setAutomaticDBInfo();
        return SQLStatement::next();
    }

    #! SQLStatement::commit with clearing of @ref instrumentation_info_auto if required
    nothing commit() {
        setAppInfo(NOTHING, False);
        m_ds.commit();
    }
    
    #! SQLStatement::rollback with clearing of @ref instrumentation_info_auto if required
    nothing rollback() {
        setAppInfo(NOTHING, False);
        m_ds.rollback();
    }
    
} # class OracleSQLStatement


} # namespace OracleExtensions




%ifdef OracleExtensionsTest
# qore -DOracleExtensionsTest=1 OracleExtensions.qm 
our string connstr = "oracle:pvanek_omq/omq@xbox";


any sub stmtTest(object o) {
    OracleExtensions::OracleSQLStatement stmt(o);
    
    stmt.prepare("select workflow_instanceid from workflow_instance where workflowid = %v and rownum < 4");
    stmt.bind(201);

    while (stmt.next()) {
        hash r = stmt.fetchRow();
        printf("row: %n\n", r);
        sleep(1);
    }
    
    stmt.commit();
    printf("connection free'd\n");
    sleep(5);
}

any sub test(object o, string m) {
    any ret = callObjectMethodArgs(o, m, argv);
    printf("%s::%s(%n) - %N\n", o.className(), m, argv, ret);
    return ret;
}

sub testData(object o1, object o2, string m) {
    #printf("test: %s\n", m);
    any d1 = callObjectMethodArgs(o1, m, argv);
    any d2 = callObjectMethodArgs(o2, m, argv);
    
    if (d1 != d2)
        throw "TEST-DATA-ERROR", sprintf("call: %s; data mismatch: %n \n\n%n", m, d1, d2);
}


our bool backRun = True;
sub backRunLogger() {
    # session status for terminal
    OracleExtensions::OracleDatasource d(connstr);
    on_exit {
        d.rollback();
    }
    d.setAppInfo("OracleExtension module", "background thread", "tty logging");
    string sql = "select sid, status, client_info, module, action from v$session where username = %v and module != 'TOra'";
    while (backRun) {
        #printf("%N\n\n", d.selectRows(sql, d.getUserName().upr()));
        sleep(1s);
    }
}

sub testLongOps(object o) {
    printf("testLongOps\n");

    OracleExtensions::OracleApplicationInfo a("Qore Test Script", sprintf("testLongOps TID:%d", gettid()), "a very long operation...");
    o.setAppInfo(a);

    int max = 10;
    OracleExtensions::OracleLongOps lo('long ops test', 'FOOBAR table', 'potatoes', max);
    for (int i = 1; i <= max; i++) {
        lo.sofar = i;
        lo.op_context = i * 1000;
        o.setLongOpsProgress(lo);
        sleep(1);
    }
    if (lo.inProgress())
        throw "DEBUG-ERROR", "lo in progress. And it's wrong";

    a.action = "another action";
    o.setAppInfo(a);
    sleep(2);
}

sub testDBMSOut(object o)
{
    printf("testDBMS\n");

    o.outputEnable();
    o.outputPutLine('foo');
    o.outputPutLine(111);
    o.outputPutLine(now());
    o.exec("begin dbms_output.put_line(%v); end;", "hey, it's server here");

    my *string res = o.outputGet();
    printf("DBMS_OUTPUT RESULT:\n%N\n", res);
    o.outputDisable();
}

our Counter autoCnt();
*OracleExtensions::OracleApplicationInfo sub getAutoInfo()
{
#    printf("getAutoInfo: called\n");
    autoCnt.inc();
    return new OracleExtensions::OracleApplicationInfo("user module",
                                                       sprintf("auto info: %d", autoCnt.getCount()),
                                                       sprintf("auto info: %n", now())
                                                    );
}

sub baseTest(object dd) {
    printf("\nBase Test for: %n\n\n", dd);
    on_exit dd.rollback();
    
    testDBMSOut(dd);
    testLongOps(dd);

    test(dd, "beginTransaction", "client test 1", "module 1", "action 1");
    test(dd, "select", "begin dbms_lock.sleep(%v); end;", 5);
    test(dd, "commit");

    test(dd, "beginTransaction", "client test 2", "module 2", "action 2");
    test(dd, "select", "begin dbms_lock.sleep(%v); end;", 5);
    test(dd, "rollback");

    test(dd, "beginTransaction");
    test(dd, "exec", "begin dbms_lock.sleep(%v); end;", 1);
    test(dd, "execRaw", "begin dbms_lock.sleep(1); end;");
    test(dd, "select", "begin dbms_lock.sleep(%v); end;", 1);
    test(dd, "selectRow", "select 1 from dual", 1);
    test(dd, "selectRows", "begin dbms_lock.sleep(%v); end;", 1);
    test(dd, "vexec", "begin dbms_lock.sleep(%v); end;", 1);
    test(dd, "vselect", "begin dbms_lock.sleep(%v); end;", 1);
    test(dd, "vselectRow", "select 1 from dual", 1);
    test(dd, "vselectRows", "begin dbms_lock.sleep(%v); end;", 1);
    test(dd, "rollback");


    test(dd, "beginTransaction", "client test3", "module 3", "action 3");

    OracleExtensions::OracleApplicationInfo info("OracleAppInfo test", "manual set", "none");

    info.action = "exec";
    test(dd, "exec", info, "begin dbms_lock.sleep(%v); end;", 1);
    info.action = "execRaw";
    test(dd, "execRaw", info, "begin dbms_lock.sleep(1); end;");
    info.action = "select";
    test(dd, "select", info, "begin dbms_lock.sleep(%v); end;", 1);
    info.action = "selectRow";
    test(dd, "selectRow", info, "select 1 from dual", 1);
    info.action = "selectRows";
    test(dd, "selectRows", info, "begin dbms_lock.sleep(%v); end;", 1);
    info.action = "vexec";
    test(dd, "vexec", info, "begin dbms_lock.sleep(%v); end;", 1);
    info.action = "vselect";
    test(dd, "vselect", info, "begin dbms_lock.sleep(%v); end;", 1);
    info.action = "vselectRow";
    test(dd, "vselectRow", info, "select 1 from dual", 1);
    info.action = "vselectRows";
    test(dd, "vselectRows", info, "begin dbms_lock.sleep(%v); end;", 1);

    sleep(2s);
}

sub testDataDiffs() {
    Datasource d1(connstr);
    OracleDatasource d2(connstr, \getAutoInfo());
    on_exit {
        d1.rollback();
        d2.rollback();
    }
    
    string sql = "select * from all_tables where owner = %v and table_name = %v order by table_name";

    testData(d1, d2, "exec", sql, d1.getUserName().upr(), "WORKFLOWS");
    testData(d1, d2, "execRaw", "select * from user_tables", d1.getUserName().upr(), "WORKFLOWS");
    testData(d1, d2, "select", sql, d1.getUserName().upr(), "WORKFLOWS");
    testData(d1, d2, "selectRow", sql, d1.getUserName().upr(), "WORKFLOWS");
    testData(d1, d2, "selectRows", sql, d1.getUserName().upr(), "WORKFLOWS");
    testData(d1, d2, "vexec", sql, (d1.getUserName().upr(), "WORKFLOWS"));
    testData(d1, d2, "vselect", sql, (d1.getUserName().upr(), "WORKFLOWS"));
    testData(d1, d2, "vselectRow", sql, (d1.getUserName().upr(), "WORKFLOWS"));
    testData(d1, d2, "vselectRows", sql, (d1.getUserName().upr(), "WORKFLOWS"));
    sleep(1s);
}

sub testPoolConnectionCount() {
    DatasourcePool ds(connstr);
    OracleDatasourcePool ds1(ds);
    OracleDatasourcePool ds2(ds);
    OracleDatasourcePool ds3(ds);
    background baseTest(ds1);
    background baseTest(ds2);
    background baseTest(ds3);
}

{
    background backRunLogger();
    on_exit backRun = False;

    OracleExtensions::OracleDatasource dd(connstr, \getAutoInfo());
    dd.setAutoCommit(False);
    baseTest(dd);
    
    OracleExtensions::OracleDatasourcePool dp(connstr, \getAutoInfo());
    baseTest(dp);
    
    testDataDiffs();

    testPoolConnectionCount();

    stmtTest(dd);
    stmtTest(dp);
}

%endif
