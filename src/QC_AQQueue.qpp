/* -*- mode: c++; indent-tabs-mode: nil -*- */
/*
*/

#include <qore/Qore.h>
#include "oracle.h"
#include "ocilib_internal.h"
#include "AQMessagePriv.h"

#include "AQQueuePriv.h"

#include <memory>

class AQThreadManager {
protected:
   pthread_t ora_thread;
   QoreThreadLock l;
   unsigned count;
   int tid;

public:
   DLLLOCAL AQThreadManager() : count(0), tid(0) {
   }

   DLLLOCAL ~AQThreadManager() {
      assert(!tid);
      assert(!count);
   }

   DLLLOCAL void inc() {
      AutoLocker al(l);
      if (!count) {
         assert(!tid);
         tid = q_reserve_foreign_thread_id();
         assert(tid > 0);
      }
      ++count;
   }

   DLLLOCAL void dec() {
      AutoLocker al(l);
      if (!--count) {
         q_release_reserved_foreign_thread_id(tid);
         tid = 0;
      }
   }

   DLLLOCAL int getTid() const {
      assert(tid);
      return tid;
   }

   DLLLOCAL unsigned getCount() const {
      return count;
   }
};

AQThreadManager aqThreadManager;

void on_async_message(OCI_Dequeue* deq) {
   QoreForeignThreadHelper qfth(aqThreadManager.getTid());;

   //printd(5, "DEBUG> message arrived pthread: %p, deq: %p obj: %p\n", pthread_self(), deq, deq->user_ctx);

   ExceptionSink xsink;
   reinterpret_cast<QoreObject*>(deq->user_ctx)->evalMethod("onAsyncMessage", 0, &xsink);
}

const char* check_hash_key(const QoreHashNode* h, const char* key, const char* err, ExceptionSink *xsink) {
   const AbstractQoreNode* p = h->getKeyValue(key);
   if (is_nothing(p))
      return 0;

   if (p->getType() != NT_STRING) {
      xsink->raiseException(err, "'%s' key is not type 'string' but is type '%s'", key, get_type_name(p));
      return 0;
   }
   return reinterpret_cast<const QoreStringNode* >(p)->getBuffer();
}

AQQueuePriv::AQQueuePriv(Datasource *ds, const QoreStringNode *tname, const QoreStringNode *qname, ExceptionSink *xsink)
    : m_conn(ds->getPrivateData<QoreOracleConnection>()),
      m_ds(ds),
      m_tname(tname->stringRefSelf()),
      m_qname(qname->stringRefSelf()),
      m_typeInfo(0),
      m_enqueue(0),
      m_dequeue(0),
      m_hasSubscription(false)
{
    connect(xsink);
    //printd(5, "PING> %d\n", ping());
}

AQQueuePriv::~AQQueuePriv() {
   assert(!m_enqueue);
   assert(!m_dequeue);
   assert(!m_typeInfo);
   assert(!m_tname);
   assert(!m_qname);
   assert(!m_ds);
}

void AQQueuePriv::deref(ExceptionSink* xsink) {
   if (ROdereference()) {
      disconnectUnlocked(xsink);
      m_tname->deref();
      m_qname->deref();
      m_ds->close();
      delete m_ds;
#ifdef DEBUG
      m_tname = 0;
      m_qname = 0;
      m_ds = 0;
#endif
      delete this;
   }
}

void AQQueuePriv::disconnect(ExceptionSink* xsink) {
   AutoLocker al(l);
   disconnectUnlocked(xsink);
}

void AQQueuePriv::disconnectUnlocked(ExceptionSink* xsink) {
   //printd(5, "AQQueuePriv::~disconnectUnlocked() this: %p m_dequeue: %p\n", this, m_dequeue);
   if (m_enqueue) {
      OCI_EnqueueFree(&m_conn->ocilib, m_enqueue);
      m_enqueue = 0;
   }
   if (m_dequeue) {
      if (m_hasSubscription)
         stopSubscriptionUnlocked(xsink);
      OCI_DequeueFree(&m_conn->ocilib, m_dequeue);
      m_dequeue = 0;
   }
   if (m_typeInfo) {
      OCI_TypeInfoFree2(&m_conn->ocilib, m_typeInfo);
      m_typeInfo = 0;
   }
}

void AQQueuePriv::connect(ExceptionSink *xsink) {
   AutoLocker al(l);
   disconnectUnlocked(xsink);

   assert(m_conn);
   m_conn->ds.open(xsink);
   if (*xsink) {
      return;
   }


   // can only call Datasource::getQoreEncoding() after the call to Datasource::open()
   TempEncodingHelper tn(m_tname, m_conn->ds.getQoreEncoding(), xsink);
   if (*xsink)
      return;

   TempEncodingHelper qn(m_qname, m_conn->ds.getQoreEncoding(), xsink);
   if (*xsink)
      return;

   // use QoreString instead of a fixed-size buffer to deal with arbitrary-length strings
   QoreStringMaker value("Qore AQ Queue: %s", qn->getBuffer());
//   if (!OCI_SetTrace(&m_conn->ocilib, m_conn->ocilib_cn, OCI_TRC_MODULE, value.getBuffer()))
//      printd(0, "TRACE FAILED\n");
   OCI_SetTrace(&m_conn->ocilib, m_conn->ocilib_cn, OCI_TRC_MODULE, value.getBuffer());

   assert(!m_typeInfo);
   m_typeInfo = OCI_TypeInfoGet2(&m_conn->ocilib, m_conn->ocilib_cn, tn->getBuffer(), OCI_TIF_TYPE);

   //printd(5, "AQQueuePriv CONNECTION> m_conn(%p)\n", m_conn);

   if (!m_typeInfo) {
      xsink->raiseException("AQ-MESSAGE-ERROR", "Cannot get type info for '%s'", m_tname->getBuffer());
      return;
   }

}

bool AQQueuePriv::ping() {
   AutoLocker al(l);
   return OCI_Ping(&m_conn->ocilib, m_conn->ocilib_cn);
}

bool AQQueuePriv::post(AQMessagePriv *message, ExceptionSink *xsink) {
   AutoLocker al(l);
   
    if (!m_enqueue) {
       //printd(5, "Opening W queue: %s (%p)\n", m_qname->getBuffer(), m_typeInfo);
       m_enqueue = OCI_EnqueueCreate(&m_conn->ocilib, m_typeInfo, m_qname->getBuffer());
       if (!m_enqueue) {
          xsink->raiseException("AQQUEUE-ERROR", "failed to initialize queue");
          return false;
       }
    }

    ReferenceHolder<QoreHashNode> obj(message->getObject(), xsink);
    if (!obj) {
        xsink->raiseException("AQQUEUE-ERROR", "no oracle object (hash) provided in the message");
        return false;
    }

    OCI_Object *o = objBindQore(m_conn, *obj, xsink);
    if (!o) {
       xsink->raiseException("AQQUEUE-ERROR", "failed to create(bind) object");
       return false;
    }
    ON_BLOCK_EXIT(OCI_ObjectFree2, &m_conn->ocilib, o);

    OCI_Msg *m = OCI_MsgCreate(&m_conn->ocilib, m_typeInfo, xsink);
    if (!m) {
       if (!*xsink)
          xsink->raiseException("AQQUEUE-ERROR", "cannot allocate message object");
       return false;
    }
    ON_BLOCK_EXIT(OCI_MsgFree, &m_conn->ocilib, m);

    if (!OCI_MsgSetObject(&m_conn->ocilib, m, o)) {
    	xsink->raiseException("AQQUEUE-ERROR", "cannot se message object");
    	return false;
    }

    if (!OCI_MsgSetEnqueueDelay(&m_conn->ocilib, m, message->getEnqueueDelay())) {
    	xsink->raiseException("AQQUEUE-ERROR", "failed to set message delay");
    	return false;
    }
    if (!OCI_MsgSetExpiration(&m_conn->ocilib, m, message->getExpiration())) {
    	xsink->raiseException("AQQUEUE-ERROR", "failed to set expiration");
    	return false;
    }
    if (!OCI_MsgSetPriority(&m_conn->ocilib, m, message->getPriority())) {
    	xsink->raiseException("AQQUEUE-ERROR", "failed to set priority");
    	return false;
    }
    
    QoreStringNodeHolder correlation(message->getCorrelation());
    
    if (*correlation) {
        TempEncodingHelper encoded(*correlation, m_conn->ds.getQoreEncoding(), xsink);
        if (*xsink)
           return false;
        if (!OCI_MsgSetCorrelation(&m_conn->ocilib, m, encoded->getBuffer())) {
    	    xsink->raiseException("AQQUEUE-ERROR", "failed to set correlation");
    	    return false;
        }
    }

    if (!OCI_EnqueuePut(&m_conn->ocilib, m_enqueue, m)) {
        xsink->raiseException("AQQUEUE-ERROR", "failed to enqueue object");
        return false;
    }

    return true;
}

bool AQQueuePriv::post(const QoreHashNode *h, ExceptionSink *xsink) {
   AutoLocker al(l);

   OCI_Object* obj = objBindQore(m_conn, h, xsink);
   if (!obj) {
      xsink->raiseException("AQQUEUE-ERROR", "failed to create(bind) object");
      return false;
   }
   ON_BLOCK_EXIT(OCI_ObjectFree2, &m_conn->ocilib, obj);
   
   OCI_Msg* msg = OCI_MsgCreate(&m_conn->ocilib, m_typeInfo, xsink);
   if (!msg) {
      if (!*xsink)
         xsink->raiseException("AQQUEUE-ERROR", "cannot allocate message");
      return false;
   }
   ON_BLOCK_EXIT(OCI_MsgFree, &m_conn->ocilib, msg);

   if (!OCI_MsgSetObject(&m_conn->ocilib, msg, obj)) {
      xsink->raiseException("AQQUEUE-ERROR", "cannot set message object");
      return false;
   }
   
   if (!OCI_EnqueuePut(&m_conn->ocilib, m_enqueue, msg)) {
      xsink->raiseException("AQQUEUE-ERROR", "failed to enqueue object");
      return false;
   }
   
   return true;
}

bool AQQueuePriv::commit(ExceptionSink *xsink) {
   AutoLocker al(l);
   return m_conn->commit(xsink);
}

bool AQQueuePriv::rollback(ExceptionSink *xsink) {
   AutoLocker al(l);
   return m_conn->rollback(xsink);
}

QoreObject* AQQueuePriv::getMessage(QoreObject* self, int timeout, ExceptionSink *xsink) {
   AutoLocker al(l);

   if (!checkDequeueUnlocked(self, xsink))
      return 0;

   //printd(5, "AQQueuePriv::getMessage() this: %p dequeue: %p msg: %p msg->typinfo: %p (%s)\n", this, m_dequeue, m_dequeue->msg, m_dequeue->msg->typinf, m_dequeue->msg->typinf->name);

   // set timeout if necessary
   if (!OCI_DequeueSetWaitTime(&m_conn->ocilib, m_dequeue, timeout, xsink)) {
      if (!*xsink)
         xsink->raiseException("AQQUEUE-ERROR", "failed to set dequeue timeout of %d second%s", timeout, timeout == 1 ? "" : "s");
      return 0;
   }

   OCI_Msg *msg = OCI_DequeueGet(&m_conn->ocilib, m_dequeue, xsink);

   if (msg == NULL) {
      printd(5, "Message is NULL. NOTHING returned.\n");
      return 0;
   }

   OCI_Object *o = OCI_MsgGetObject(&m_conn->ocilib, msg);    

   if (!o) {
      printd(5, "AQQueuePriv::getMessage() object in message is NULL\n");
      return 0;
   }

    ON_BLOCK_EXIT(OCI_ObjectFree2, &m_conn->ocilib, o);

    AbstractQoreNode * obj = objToQore(m_conn, o, xsink);
    if (!obj) {
       xsink->raiseException("AQQUEUE-ERROR", "Cannot get qore hash from OCI object");
       return 0;
    }
    assert(obj->getType() == NT_HASH);

    AQMessagePriv *qop = new AQMessagePriv(reinterpret_cast<QoreHashNode*>(obj), xsink);
    QoreObject *qo = new QoreObject(QC_AQMESSAGE, getProgram(), qop);
    printd(5, "AQQueuePriv::getMessage() this: %p returning obj: %p\n", this, qo);
    return qo;
}

bool AQQueuePriv::checkDequeueUnlocked(QoreObject* self, ExceptionSink *xsink) {
   if (!m_dequeue) {
      //printd(5, "AQQueuePriv::checkDequeueUnlocked() this: %p Opening R queue: %s (%p)\n", this, m_qname->getBuffer(), m_typeInfo);
      m_dequeue = OCI_DequeueCreate(&m_conn->ocilib, m_typeInfo, m_qname->getBuffer(), xsink);
      if (!m_dequeue) {
         if (!*xsink)
            xsink->raiseException("AQQUEUE-ERROR", "failed to initialize queue");
         return false;
      }
      m_dequeue->user_ctx = (void*)self;
      //printd(5, "AQQueuePriv::checkDequeueUnlocked() this: %p DEQUEUE ptr: %p msg: %p m_typeInfo: %p msg->typinfo: %p (%s)\n", this, m_dequeue, m_dequeue->msg, m_typeInfo, m_dequeue->msg->typinf, m_dequeue->msg->typinf->name);
   }
   return true;
   // TODO
   //OCI_DequeueSetConsumer for list
}

void AQQueuePriv::startSubscription(QoreObject* self, int64 port, int64 timeout, ExceptionSink *xsink) {
   AutoLocker al(l);
   if (!checkDequeueUnlocked(self, xsink))
      return;

   if (m_hasSubscription) {
      xsink->raiseException("AQQUEUE-ERROR", "a subscription is already set with this AQQueue object; call AQQueue::stopSubscription() first before calling AQQueue::startSubscription()");
      return;
   }

   //printd(5, "AQQueuePriv::startSubscription() this: %p dequeue: %p self: %p port: %zd timeout: %zd\n", this, m_dequeue, self, port, timeout);

   // increment "oracle-thread active" count
   aqThreadManager.inc();

   if (!OCI_DequeueSubscribe(&m_conn->ocilib, m_dequeue, port, timeout, on_async_message, xsink)) {
      // decrement "oracle-thread active" count
      aqThreadManager.dec();
      if (!*xsink)
         xsink->raiseException("AQQUEUE-ERROR", "unknown error starting the subscription");
      return;
   }

   m_hasSubscription = true;
   
   //printd(5, "AQQueuePriv::startSubscription() this: %p dequeue: %p self: %p callback: %p\n", this, m_dequeue, self, m_dequeue->callback);
}

int AQQueuePriv::stopSubscriptionUnlocked(ExceptionSink *xsink) {
   assert(m_dequeue);
   assert(m_hasSubscription);

   bool b = OCI_DequeueUnsubscribe(&m_conn->ocilib, m_dequeue, xsink);
   aqThreadManager.dec();
   m_hasSubscription = false;

   if (!b) {
      if (!*xsink)
         xsink->raiseException("AQQUEUE-ERROR", "unknown error stopping the subscription");
      return -1;
   }

   return 0;
}

int AQQueuePriv::stopSubscription(ExceptionSink *xsink) {
   AutoLocker al(l);
   //printd(5, "AQQueuePriv::stopSubscription() this: %p m_dequeue: %p m_hasSubscription: %d\n", this, m_dequeue, (int)m_hasSubscription);

   if (!m_hasSubscription)
      return 0;

   stopSubscriptionUnlocked(xsink);
   return 0;
}

static int ds_set_options(Datasource& ds, const QoreHashNode* opts, ExceptionSink* xsink) {
   ConstHashIterator hi(opts);
   while (hi.next()) {
      // skip "min" and "max" options
      if (!strcmp(hi.getKey(), "min") || !strcmp(hi.getKey(), "max"))
         continue;

      if (ds.setOption(hi.getKey(), hi.getValue(), xsink))
         return -1;
   }
   return 0;
}

static void aqqueue_constructor_hash(const QoreStringNode* queueName, const QoreStringNode* typeName, const QoreHashNode* opts, QoreObject* self, ExceptionSink* xsink) {
   static const char *DSC_ERR = "AQQUEUE-CONSTRUCTOR-ERROR";

   const char* str = check_hash_key(opts, "type", DSC_ERR, xsink);
   if (*xsink) return;

   if (str && strcmp(str, "oracle")) {
      xsink->raiseException(DSC_ERR, "if the 'type' key is present, then it must be 'oracle'; value provided: '%s'", str);
      return;
   }

   DBIDriver *db_driver = DBI.find("oracle", xsink);
   // driver must be laoded because it's being executed now :)
   assert(db_driver);

   std::auto_ptr<Datasource> ds(new Datasource(db_driver));

   str = check_hash_key(opts, "user", DSC_ERR, xsink);
   if (*xsink) return;
   if (str) ds->setPendingUsername(str);

   str = check_hash_key(opts, "pass", DSC_ERR, xsink);
   if (*xsink) return;
   if (str) ds->setPendingPassword(str);

   str = check_hash_key(opts, "db", DSC_ERR, xsink);
   if (*xsink) return;
   if (str) ds->setPendingDBName(str);

   str = check_hash_key(opts, "charset", DSC_ERR, xsink);
   if (*xsink) return;
   if (str) ds->setPendingDBEncoding(str);

   str = check_hash_key(opts, "host", DSC_ERR, xsink);
   if (*xsink) return;
   if (str) ds->setPendingHostName(str);

   bool found;
   int port = (int)opts->getKeyAsBigInt("port", found);
   if (port) {
      if (port < 0) {
         xsink->raiseException(DSC_ERR, "port value must be zero (meaning use the default port) or positive (value given: %d)", port);
         return;
      }

      ds->setPendingPort(port);
   }

   {
      const AbstractQoreNode* p = opts->getKeyValue("options");

      if (!is_nothing(p)) {
         if (get_node_type(p) != NT_HASH) {
            xsink->raiseException(DSC_ERR, "'options' key is not type 'hash' but is type '%s'", get_type_name(p));
            return;
         }
         const QoreHashNode *oh = reinterpret_cast<const QoreHashNode*>(p);
         if (ds_set_options(*ds.get(), oh, xsink))
            return;
      }
   }

   ds->open(xsink);
   if (*xsink) {
      return;
   }

   self->setPrivate(CID_AQQUEUE, new AQQueuePriv(ds.release(), typeName, queueName, xsink));
}

//! Implementation of AQ Queue.
/**
 * AQ messages notification with Oracle Client 10gR2 or above
 */
qclass AQQueue [dom=DATABASE; arg=AQQueuePriv* priv; ns=Qore::Oracle];

//! Construct a queue object for posting/getting messages from a datasource description string
/** @param queueName a mandatory name of the queue in the database
    @param typeName a mandatory name of the type for this queue in the DB
    @param desc a datasource description string in the format that can be parsed by parse_datasource()

    @throw AQQUEUE-CONSTRUCTOR-ERROR invalid arguments to constructor
    @throw DBI-OPTION-ERROR unknown or unsupported option passed to the Oracle driver
 */
AQQueue::constructor(string queueName, string typeName, string desc) {
   ReferenceHolder<QoreHashNode> h(parseDatasource(desc->getBuffer(), xsink), xsink);
   if (!h) {
      assert(*xsink);
      return;
   }
   aqqueue_constructor_hash(queueName, typeName, *h, self, xsink);
   return;
}

//! Construct a queue object for posting/getting messages.
/** @param queueName a mandatory name of the queue in the database
    @param typeName a mandatory name of the type for this queue in the DB
    @param opts a hash giving parameters for the new dedicated connection to the Oracle database server with the following possible keys (the \c "type" key is optional, but if present, must be \c "oracle"):
    - \c type: (@ref string_or_nothing_type "*string") The name of the database driver to use; this key is optional, but if present must be \c "oracle" or an exception will be raised
    - \c user: (@ref string "string") The user name for the new connection
    - \c pass: (@ref string "string") The password for the new connection
    - \c db: (@ref string "string") The database name for the new connection
    - \c charset: (@ref string_or_nothing_type "*string") The Oracle-specific name of the character encoding to use for the new connection. If no value is passed for this parameter, then the Oracle character encoding corresponding to the default character encoding for the %Qore process will be used instead.
    - \c host: (@ref string_or_nothing_type "*string") The host name for the new connection
    - \c port: (@ref softint_type "softint") The port number for the new connection. If this key is present and is 0 then an exception will be raised.
    - \c options: (@ref hash_or_nothing_type "*hash") Any options for the new connection

    @throw AQQUEUE-CONSTRUCTOR-ERROR invalid arguments to constructor    
    @throw DBI-OPTION-ERROR unknown or unsupported option passed to the Oracle driver
 */
AQQueue::constructor(string queueName, string typeName, hash opts) {
   aqqueue_constructor_hash(queueName, typeName, opts, self, xsink);
}

//! stops any active subscriptions and destroys the object
/**
 */
AQQueue::destructor() {
   priv->disconnect(xsink);
}

//! Copying objects of this class is not supported, an exception will be thrown
/** 
    @throw AQQUEUE-COPY-ERROR copying AQQueue objects is not yet supported
 */
AQQueue::copy() {
   xsink->raiseException("AQQUEUE-COPY-ERROR", "copying AQQueue objects is currently not supported");
}

//! Post the AQMessage into the queue.
/** @param msg a AQMessage instance
 */
nothing AQQueue::post(AQMessage[AQMessagePriv] msg) {
    priv->post(msg, xsink);
}

//! Post the plain Oracle object hash into the queue.
/** @param msg a qore hash (Oracle object)
 *
 * The hash/object will use default message properties. Use post() with an
 * AQMessage instance if you need to modify the message defaults.
 */
nothing AQQueue::post(hash msg) {
   priv->post(msg, xsink);
}

//! Get message from queue
/** @param timeout the timeout in seconds; 0 = no timeout

    @retval AQMessage or NOTHING if no message was available in the timeout period
 */
*AQMessage AQQueue::getMessage(softint timeout = 0) {
   return priv->getMessage(self, timeout, xsink);
}

//! Subscribe for asynchronous messages notifications
/** @param port an optional port number
    @param timeout an optional timeout value in seconds; any positive value in seconds is valid. The value 0 is accepted and means that it does not wait for messages and returns immediately if no messages are available.  The value -1 is accepted and means it waits for ever (until a message is available in the queue)

    @throw AQQUEUE-ERROR port or timeout value invalid; subscription already active for this object 
 */
nothing AQQueue::startSubscription(int port = 0, int timeout = 0) {
   if (port < 0) {
      xsink->raiseException("AQQUEUE-ERROR", "Port number has to be greater than or equal to 0");
      return 0;
   }
   
   if (timeout < -1) {
      xsink->raiseException("AQQUEUE-ERROR", "Timeout value has to be greater than or equal to -1");
      return 0;
   }
   
   priv->startSubscription(self, port, timeout, xsink);
}

//! Unsubscribe for asynchronous messages notifications.
/** If no subscription is active, no action is taken

    @throw AQQUEUE-ERROR oracle error stopping the subscription
 */
nothing AQQueue::stopSubscription() {
   priv->stopSubscription(xsink);
}

//! Commit the transaction.
/** Confirm all posted or fetched messages.
 */
bool AQQueue::commit() {
    return priv->commit(xsink);
}

//! Rollback the transaction.
/** Rollback all posted or fetched messages.
 */
bool AQQueue::rollback() {
    return priv->rollback(xsink);
}

//! Automatically called when a new message is received on the queue when there is an active subscription
/** A method which is called when there is a new message in the queue.
    
    The default implementation throws an exception; this method must be overridden in subclasses to receive messages; 
    use the @ref AQQueue::getMessage() method to receive the message

    @throw AQQUEUE-ONASYNCMESSAGE-ERROR abstract implementation of AQQueue::onAsyncMessage called
 */
nothing AQQueue::onAsyncMessage() {
   xsink->raiseException("AQQUEUE-ONASYNCMESSAGE-ERROR", "abstract implementation of AQQueue::onAsyncMessage called");
}
