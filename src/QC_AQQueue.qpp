/* -*- mode: c++; indent-tabs-mode: nil -*- */
/*
*/

#include <qore/Qore.h>
#include "oracle.h"
#include "ocilib_internal.h"
#include "AQMessagePriv.h"

#include "AQQueuePriv.h"

#include <memory>

class AQDequeueMap {
   QoreThreadLock m_lock;
   typedef std::map<OCI_Dequeue*,QoreObject*> m_map_t;
   m_map_t m_map;

public:
    DLLLOCAL AQDequeueMap() {
    }

    DLLLOCAL ~AQDequeueMap() {
        assert(m_map.empty());
    }

    DLLLOCAL void set(OCI_Dequeue* deq, QoreObject* o) {
        AutoLocker al(m_lock);
        assert(m_map.find(deq) == m_map.end());
        o->tRef();
        m_map[deq] = o;
    }

    DLLLOCAL QoreObject* get(OCI_Dequeue *deq) {
        AutoLocker al(m_lock);
        m_map_t::const_iterator i = m_map.find(deq);
        assert(i != m_map.end());
        return i->second;
    }

    DLLLOCAL void remove(OCI_Dequeue *deq) {
        QoreObject *o;
        {
            AutoLocker al(m_lock);
            m_map_t::iterator i = m_map.find(deq);
            assert(i != m_map.end());
            o = i->second;
            m_map.erase(i);
        }
        o->tDeref();
    }
};

static AQDequeueMap dequeueMap;

void on_async_message(OCI_Dequeue *deq) {
    QoreForeignThreadHelper qfth;

    printd(0, "DEBUG> message arrived pthread: %p\n", pthread_self());
    printd(0, "       deq: %p\n", deq);
    assert(dequeueMap.get(deq));
    printd(0, "       OCI_Dequeue instance: %p\n", deq);
    printd(0, "        QoreObject instance: %p\n\n", dequeueMap.get(deq));

    ExceptionSink xsink;
    dequeueMap.get(deq)->evalMethod("onAsyncMessage", 0, &xsink);
    if (xsink) { printd(0, "EXCEPTION\n"); }
}


const char* check_hash_key(const QoreHashNode* h, const char* key, const char* err, ExceptionSink *xsink) {
   const AbstractQoreNode* p = h->getKeyValue(key);
   if (is_nothing(p))
      return 0;

   if (p->getType() != NT_STRING) {
      xsink->raiseException(err, "'%s' key is not type 'string' but is type '%s'", key, get_type_name(p));
      return 0;
   }
   return reinterpret_cast<const QoreStringNode* >(p)->getBuffer();
}

AQQueuePriv::AQQueuePriv(Datasource *ds, const QoreStringNode *tname, const QoreStringNode *qname, ExceptionSink *xsink)
    : m_conn(ds->getPrivateData<QoreOracleConnection>()),
      m_ds(ds),
      m_tname(tname->stringRefSelf()),
      m_qname(qname->stringRefSelf()),
      m_typeInfo(0),
      m_enqueue(0),
      m_dequeue(0),
      m_hasSubscription(false)
{
    connect(xsink);
    printd(0, "PING> %d\n", ping());
}

AQQueuePriv::~AQQueuePriv() {
   assert(!m_enqueue);
   assert(!m_dequeue);
   assert(!m_typeInfo);
   assert(!m_tname);
   assert(!m_qname);
   assert(!m_ds);
}

void AQQueuePriv::deref(ExceptionSink* xsink) {
   if (ROdereference()) {
      disconnectUnlocked(xsink);
      m_tname->deref();
      m_qname->deref();
      m_ds->close();
      delete m_ds;
#ifdef DEBUG
      m_tname = 0;
      m_qname = 0;
      m_ds = 0;
#endif
      delete this;
   }
}

void AQQueuePriv::disconnect(ExceptionSink* xsink) {
   AutoLocker al(l);
   disconnectUnlocked(xsink);
}

void AQQueuePriv::disconnectUnlocked(ExceptionSink* xsink) {
    printd(0, "AQQueuePriv::~disconnectUnlocked() this: %p m_dequeue: %p\n", this, m_dequeue);
    if (m_enqueue) {
       OCI_EnqueueFree(&m_conn->ocilib, m_enqueue);
       m_enqueue = 0;
    }
    if (m_dequeue) {
       if (m_hasSubscription)
          stopSubscriptionUnlocked(xsink);
       OCI_DequeueFree(&m_conn->ocilib, m_dequeue);
       m_dequeue = 0;
    }
    if (m_typeInfo) {
       OCI_TypeInfoFree2(&m_conn->ocilib, m_typeInfo);
       m_typeInfo = 0;
    }
}

void AQQueuePriv::connect(ExceptionSink *xsink) {
   AutoLocker al(l);
   disconnectUnlocked(xsink);

   assert(m_conn);
   m_conn->ds.open(xsink);
   if (*xsink) {
      return;
   }

   // can only call Datasource::getQoreEncoding() after the call to Datasource::open()
   TempEncodingHelper tn(m_tname, m_conn->ds.getQoreEncoding(), xsink);
   if (*xsink)
      return;

   TempEncodingHelper qn(m_qname, m_conn->ds.getQoreEncoding(), xsink);
   if (*xsink)
      return;

   assert(!m_typeInfo);
   m_typeInfo = OCI_TypeInfoGet2(&m_conn->ocilib, m_conn->ocilib_cn, tn->getBuffer(), OCI_TIF_TYPE);

   printd(0, "AQQueuePriv CONNECTION> m_conn(%p)\n", m_conn);

   if (!m_typeInfo) {
      xsink->raiseException("AQ-MESSAGE-ERROR", "Cannot get type info for '%s'", m_tname->getBuffer());
      return;
   }

   // use QoreString instead of a fixed-size buffer to deal with arbitrary-length strings
   QoreStringMaker value("Qore AQ Queue: %s", qn->getBuffer());
   if (!OCI_SetTrace(&m_conn->ocilib, m_conn->ocilib_cn, OCI_TRC_MODULE, value.getBuffer()))
      printd(0, "TRACE FAILED\n\n\n");
}

bool AQQueuePriv::ping() {
   AutoLocker al(l);
   return OCI_Ping(&m_conn->ocilib, m_conn->ocilib_cn);
}

bool AQQueuePriv::postMessage(AQMessagePriv *message, ExceptionSink *xsink) {
   AutoLocker al(l);
   
    if (!m_enqueue) {
       printd(0, "Opening W queue: %s (%p)\n", m_qname->getBuffer(), m_typeInfo);
       m_enqueue = OCI_EnqueueCreate(&m_conn->ocilib, m_typeInfo, m_qname->getBuffer());
       if (!m_enqueue) {
          xsink->raiseException("AQQUEUE-ERROR", "failed to initialize queue");
          return false;
       }
    }

    ReferenceHolder<QoreHashNode> obj(message->getObject(), xsink);
    if (!obj) {
        xsink->raiseException("AQQUEUE-ERROR", "no oracle object (hash) provided in the message");
        return false;
    }

    OCI_Object *o = objBindQore(m_conn, *obj, xsink);
    if (!o) {
       xsink->raiseException("AQQUEUE-ERROR", "failed to create(bind) object");
       return false;
    }
    ON_BLOCK_EXIT(OCI_ObjectFree2, &m_conn->ocilib, o);

    OCI_Msg *m = OCI_MsgCreate(&m_conn->ocilib, m_typeInfo);
    if (!m) {
    	xsink->raiseException("AQQUEUE-ERROR", "cannot allocate message object");
    	return false;
    }
    ON_BLOCK_EXIT(OCI_MsgFree, &m_conn->ocilib, m);

    if (!OCI_MsgSetObject(&m_conn->ocilib, m, o)) {
    	xsink->raiseException("AQQUEUE-ERROR", "cannot se message object");
    	return false;
    }

    if (!OCI_MsgSetEnqueueDelay(&m_conn->ocilib, m, message->getEnqueueDelay())) {
    	xsink->raiseException("AQQUEUE-ERROR", "failed to set message delay");
    	return false;
    }
    if (!OCI_MsgSetExpiration(&m_conn->ocilib, m, message->getExpiration())) {
    	xsink->raiseException("AQQUEUE-ERROR", "failed to set expiration");
    	return false;
    }
    if (!OCI_MsgSetPriority(&m_conn->ocilib, m, message->getPriority())) {
    	xsink->raiseException("AQQUEUE-ERROR", "failed to set priority");
    	return false;
    }
    
    QoreStringNodeHolder correlation(message->getCorrelation());
    
    if (*correlation) {
        TempEncodingHelper encoded(*correlation, m_conn->ds.getQoreEncoding(), xsink);
        if (*xsink)
           return false;
        if (!OCI_MsgSetCorrelation(&m_conn->ocilib, m, encoded->getBuffer())) {
    	    xsink->raiseException("AQQUEUE-ERROR", "failed to set correlation");
    	    return false;
        }
    }

    if (!OCI_EnqueuePut(&m_conn->ocilib, m_enqueue, m)) {
        xsink->raiseException("AQQUEUE-ERROR", "failed to enqueue object");
        return false;
    }

    return true;
}

bool AQQueuePriv::postObject(const QoreHashNode *h, ExceptionSink *xsink) {
   AutoLocker al(l);

   OCI_Object* obj = objBindQore(m_conn, h, xsink);
   if (!obj) {
      xsink->raiseException("AQQUEUE-ERROR", "failed to create(bind) object");
      return false;
   }
   ON_BLOCK_EXIT(OCI_ObjectFree2, &m_conn->ocilib, obj);
   
   OCI_Msg* msg = OCI_MsgCreate(&m_conn->ocilib, m_typeInfo);
   if (!msg) {
      xsink->raiseException("AQQUEUE-ERROR", "cannot allocate message");
      return false;
   }
   ON_BLOCK_EXIT(OCI_MsgFree, &m_conn->ocilib, msg);

   if (!OCI_MsgSetObject(&m_conn->ocilib, msg, obj)) {
      xsink->raiseException("AQQUEUE-ERROR", "cannot set message object");
      return false;
   }
   
   if (!OCI_EnqueuePut(&m_conn->ocilib, m_enqueue, msg)) {
      xsink->raiseException("AQQUEUE-ERROR", "failed to enqueue object");
      return false;
   }
   
   return true;
}

bool AQQueuePriv::commit(ExceptionSink *xsink) {
   AutoLocker al(l);
   return m_conn->commit(xsink);
}

bool AQQueuePriv::rollback(ExceptionSink *xsink) {
   AutoLocker al(l);
   return m_conn->rollback(xsink);
}

QoreObject* AQQueuePriv::getMessage(ExceptionSink *xsink) {
   AutoLocker al(l);

   if (!checkDequeueUnlocked(xsink))
      return 0;

    printd(0, "AQQueuePriv::getMessage() this: %p dequeue: %p msg: %p msg->typinfo: %p (%s)\n", this, m_dequeue, m_dequeue->msg, m_dequeue->msg->typinf, m_dequeue->msg->typinf->name);

    OCI_Msg *msg = OCI_DequeueGet(&m_conn->ocilib, m_dequeue);

    if (msg == NULL) {
        printd(0, "Message is NULL. NOTHING returned.\n");
        return 0;
    }

    OCI_Object *o = OCI_MsgGetObject(&m_conn->ocilib, msg);    

    if (!o) {
        xsink->raiseException("AQQUEUE-ERROR", "Cannot get object from message");
        return 0;
    }

    ON_BLOCK_EXIT(OCI_ObjectFree2, &m_conn->ocilib, o);

    AbstractQoreNode * obj = objToQore(m_conn, o, xsink);
    if (!obj) {
       xsink->raiseException("AQQUEUE-ERROR", "Cannot get qore hash from OCI object");
       return 0;
    }
    assert(obj->getType() == NT_HASH);

    AQMessagePriv *qop = new AQMessagePriv(reinterpret_cast<QoreHashNode*>(obj), xsink);
    QoreObject *qo = new QoreObject(QC_AQMESSAGE, getProgram(), qop);
    printd(0, "AQQueuePriv::getMessage() this: %p returning obj: %p\n", this, qo);
    return qo;
}

bool AQQueuePriv::checkDequeueUnlocked(ExceptionSink *xsink) {
   if (!m_dequeue) {
      printd(0, "AQQueuePriv::checkDequeueUnlocked() this: %p Opening R queue: %s (%p)\n", this, m_qname->getBuffer(), m_typeInfo);
      m_dequeue = OCI_DequeueCreate(&m_conn->ocilib, m_typeInfo, m_qname->getBuffer());
      if (!m_dequeue) {
         xsink->raiseException("AQQUEUE-ERROR", "failed to initialize queue");
         return false;
      }
      printd(0, "AQQueuePriv::checkDequeueUnlocked() this: %p DEQUEUE ptr: %p msg: %p m_typeInfo: %p msg->typinfo: %p (%s)\n", this, m_dequeue, m_dequeue->msg, m_typeInfo, m_dequeue->msg->typinf, m_dequeue->msg->typinf->name);
      if (!OCI_DequeueSetWaitTime(&m_conn->ocilib, m_dequeue, 0)) {
         xsink->raiseException("AQQUEUE-ERROR", "failed to set dequeue timeout");
         return false;
      }
   }
   return true;
   // TODO
   //OCI_DequeueSetConsumer for list
}

void AQQueuePriv::startSubscription(QoreObject *qo, int64 port, int64 timeout, ExceptionSink *xsink) {
   AutoLocker al(l);
   if (!checkDequeueUnlocked(xsink))
      return;

   if (m_hasSubscription) {
      xsink->raiseException("AQQUEUE-ERROR", "a subscription is already set with this AQQueue object; call AQQueue::stopSubscription() first before calling AQQueue::startSubscription()");
      return;
   }

   printd(0, "AQQueuePriv::startSubscription() this: %p qo: %p port: %zd timeout: %zd\n", this, qo, port, timeout);

    if (!OCI_DequeueSubscribe(&m_conn->ocilib, m_dequeue, port, timeout, on_async_message)) {
        xsink->raiseException("AQQUEUE-ERROR", "cannot start the subscription");
        return;
    }

   dequeueMap.set(m_dequeue, qo);
   m_hasSubscription = true;
   
   printd(0, "SUBSCR DEQUEUE ptr: %p - %p\n", m_dequeue, qo);
}

int AQQueuePriv::stopSubscriptionUnlocked(ExceptionSink *xsink) {
   assert(m_dequeue);

   if (!OCI_DequeueUnsubscribe(&m_conn->ocilib, m_dequeue)) {
      xsink->raiseException("AQQUEUE-ERROR", "cannot stop the subscription");
      return -1;
   }
   
   dequeueMap.remove(m_dequeue);
   m_hasSubscription = false;
   return 0;
}

int AQQueuePriv::stopSubscription(ExceptionSink *xsink) {
   AutoLocker al(l);
   printd(0, "AQQueuePriv::stopSubscription() this: %p m_dequeue: %p m_hasSubscription: %d\n", this, m_dequeue, (int)m_hasSubscription);

   if (!m_hasSubscription)
      return 0;

   stopSubscriptionUnlocked(xsink);
   return 0;
}

static int ds_set_options(Datasource& ds, const QoreHashNode* opts, ExceptionSink* xsink) {
   ConstHashIterator hi(opts);
   while (hi.next()) {
      // skip "min" and "max" options
      if (!strcmp(hi.getKey(), "min") || !strcmp(hi.getKey(), "max"))
         continue;

      if (ds.setOption(hi.getKey(), hi.getValue(), xsink))
         return -1;
   }
   return 0;
}

static void aqqueue_constructor_hash(const QoreStringNode* queueName, const QoreStringNode* typeName, const QoreHashNode* opts, QoreObject* self, ExceptionSink* xsink) {
   static const char *DSC_ERR = "AQQUEUE-CONSTRUCTOR-ERROR";

   const char* str = check_hash_key(opts, "type", DSC_ERR, xsink);
   if (*xsink) return;

   if (str && strcmp(str, "oracle")) {
      xsink->raiseException(DSC_ERR, "if the 'type' key is present, then it must be 'oracle'; value provided: '%s'", str);
      return;
   }

   DBIDriver *db_driver = DBI.find("oracle", xsink);
   // driver must be laoded because it's being executed now :)
   assert(db_driver);

   std::auto_ptr<Datasource> ds(new Datasource(db_driver));

   str = check_hash_key(opts, "user", DSC_ERR, xsink);
   if (*xsink) return;
   if (str) ds->setPendingUsername(str);

   str = check_hash_key(opts, "pass", DSC_ERR, xsink);
   if (*xsink) return;
   if (str) ds->setPendingPassword(str);

   str = check_hash_key(opts, "db", DSC_ERR, xsink);
   if (*xsink) return;
   if (str) ds->setPendingDBName(str);

   str = check_hash_key(opts, "charset", DSC_ERR, xsink);
   if (*xsink) return;
   if (str) ds->setPendingDBEncoding(str);

   str = check_hash_key(opts, "host", DSC_ERR, xsink);
   if (*xsink) return;
   if (str) ds->setPendingHostName(str);

   bool found;
   int port = (int)opts->getKeyAsBigInt("port", found);
   if (port) {
      if (port < 0) {
         xsink->raiseException(DSC_ERR, "port value must be zero (meaning use the default port) or positive (value given: %d)", port);
         return;
      }

      ds->setPendingPort(port);
   }

   {
      const AbstractQoreNode* p = opts->getKeyValue("options");

      if (!is_nothing(p)) {
         if (get_node_type(p) != NT_HASH) {
            xsink->raiseException(DSC_ERR, "'options' key is not type 'hash' but is type '%s'", get_type_name(p));
            return;
         }
         const QoreHashNode *oh = reinterpret_cast<const QoreHashNode*>(p);
         if (ds_set_options(*ds.get(), oh, xsink))
            return;
      }
   }

   ds->open(xsink);
   if (*xsink) {
      return;
   }

   self->setPrivate(CID_AQQUEUE, new AQQueuePriv(ds.release(), typeName, queueName, xsink));
}

//! Implementation of AQ Queue.
/**
 * AQ messages notification with Oracle Client 10gR2 or above
 */
qclass AQQueue [dom=DATABASE; arg=AQQueuePriv* priv; ns=Qore::Oracle];

//! Construct a queue object for posting/getting messages from a datasource description string
/** @param queueName a mandatory name of the queue in the database
    @param typeName a mandatory name of the type for this queue in the DB
    @param desc a datasource description string in the format that can be parsed by parse_datasource()

    @throw AQQUEUE-CONSTRUCTOR-ERROR invalid arguments to constructor
    @throw DBI-OPTION-ERROR unknown or unsupported option passed to the Oracle driver
 */
AQQueue::constructor(string queueName, string typeName, string desc) {
   ReferenceHolder<QoreHashNode> h(parseDatasource(desc->getBuffer(), xsink), xsink);
   if (!h) {
      assert(*xsink);
      return;
   }
   aqqueue_constructor_hash(queueName, typeName, *h, self, xsink);
   return;
}

//! Construct a queue object for posting/getting messages.
/** @param queueName a mandatory name of the queue in the database
    @param typeName a mandatory name of the type for this queue in the DB
    @param opts a hash giving parameters for the new dedicated connection to the Oracle database server with the following possible keys (the \c "type" key is optional, but if present, must be \c "oracle"):
    - \c type: (@ref string_or_nothing_type "*string") The name of the database driver to use; this key is optional, but if present must be \c "oracle" or an exception will be raised
    - \c user: (@ref string "string") The user name for the new connection
    - \c pass: (@ref string "string") The password for the new connection
    - \c db: (@ref string "string") The database name for the new connection
    - \c charset: (@ref string_or_nothing_type "*string") The Oracle-specific name of the character encoding to use for the new connection. If no value is passed for this parameter, then the Oracle character encoding corresponding to the default character encoding for the %Qore process will be used instead.
    - \c host: (@ref string_or_nothing_type "*string") The host name for the new connection
    - \c port: (@ref softint_type "softint") The port number for the new connection. If this key is present and is 0 then an exception will be raised.
    - \c options: (@ref hash_or_nothing_type "*hash") Any options for the new connection

    @throw AQQUEUE-CONSTRUCTOR-ERROR invalid arguments to constructor    
    @throw DBI-OPTION-ERROR unknown or unsupported option passed to the Oracle driver
 */
AQQueue::constructor(string queueName, string typeName, hash opts) {
   aqqueue_constructor_hash(queueName, typeName, opts, self, xsink);
}

//! Copying objects of this class is not supported, an exception will be thrown
/** 
    @throw AQQUEUE-COPY-ERROR copying AQQueue objects is not yet supported
 */
AQQueue::copy() {
   xsink->raiseException("AQQUEUE-COPY-ERROR", "copying AQQueue objects is currently not supported");
}

//! Post the AQMessage into the queue.
/** @param msg a AQMessage instance
 */
nothing AQQueue::postMessage(AQMessage[AQMessagePriv] msg) {
    priv->postMessage(msg, xsink);
}

//! Post the plain Oracle object hash into the queue.
/** @param msg a qore hash (Oracle object)
 *
 * The hash/object will use default message properties. Use postMessage() with
 * AQMessage instance if you need to modify message defaults.
 */
nothing AQQueue::postObject(hash msg) {
   priv->postObject(msg, xsink);
}

//! Get message from queue
/** @retval AQMessage or NOTHING
 */
*AQMessage AQQueue::getMessage() {
//	AbstractQoreNode *n = priv->getMessage(xsink);
//	if (!n)
//		return 0;
//
//	if (n == Nothing)
//		return Nothing;
//	else
//		return reinterpret_cast<QoreObject*>(n);

	return priv->getMessage(xsink);
}

//! Subscribe for asynchronous messages notifications
/** @param port an optional port number
    @param timeout an optional timeout value in seconds; any positive value in seconds is valid. The value 0 is accepted and means that it does not wait for messages and returns immediately if no messages are available.  The value -1 is accepted and means it waits for ever (until a message is available in the queue)

    @throw AQQUEUE-ERROR port or timeout value invalid; subscription already active for this object 
 */
nothing AQQueue::startSubscription(int port = 0, int timeout = 0) {
   if (port < 0) {
      xsink->raiseException("AQQUEUE-ERROR", "Port number has to be greater than or equal to 0");
      return 0;
   }
   
   if (timeout < -1) {
      xsink->raiseException("AQQUEUE-ERROR", "Timeout value has to be greater than or equal to -1");
      return 0;
   }
   
   priv->startSubscription(self, port, timeout, xsink);
}

//! Unsubscribe for asynchronous messages notifications.
/** If no subscription is active, no action is taken

    @throw AQQUEUE-ERROR oracle error stopping the subscription
 */
nothing AQQueue::stopSubscription() {
   priv->stopSubscription(xsink);
}

//! Commit the transaction.
/** Confirm all posted or fetched messages.
 */
bool AQQueue::commit() {
    return priv->commit(xsink);
}

//! Rollback the transaction.
/** Rollback all posted or fetched messages.
 */
bool AQQueue::rollback() {
    return priv->rollback(xsink);
}

//! Automatically called when a new message is received on the queue when there is an active subscription
/** A method which is called when there is a new message in the queue.
    
    The default implementation throws an exception; this method must be overridden in subclasses to receive messages; 
    use the @ref AQQueue::getMessage() method to receive the message

    @throw AQQUEUE-ONASYNCMESSAGE-ERROR abstract implementation of AQQueue::onAsyncMessage called
 */
nothing AQQueue::onAsyncMessage() {
   xsink->raiseException("AQQUEUE-ONASYNCMESSAGE-ERROR", "abstract implementation of AQQueue::onAsyncMessage called");
}
